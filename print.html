<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Enabling SQLite in canisters with &#x60;ic-ruslite&#x60;</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Documentation for the &#x60;ic-rusqlite&#x60; convenience package">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./mdbook-admonish.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Enabling SQLite in canisters with &#x60;ic-ruslite&#x60;</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/wasm-forge/ic-rusqlite" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to <strong>ic-rusqlite</strong>, a convenience wrapper around the crate <a href="https://crates.io/crates/rusqlite"><code>rusqlite</code></a> for integrating SQLite databases in Internet Computer (IC) canisters.</p>
<p><a href="https://www.sqlite.org/">SQLite</a> is a lightweight, embedded database engine. <code>ic-rusqlite</code> allows to use the SQLite server on your Rust-based IC projects.</p>
<p>This guide explains how to install, configure, and optimize <code>ic-rusqlite</code>, including practical examples, performance considerations, and best practices.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<h2 id="required-tools"><a class="header" href="#required-tools">Required Tools</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch01-01-installation.html">Rust</a></li>
<li><a href="https://internetcomputer.org/docs/current/developer-docs/setup/install/">DFX</a></li>
</ul>
<h2 id="setting-up-the-environment"><a class="header" href="#setting-up-the-environment">Setting Up the Environment</a></h2>
<p>You can setup your build environment via script:</p>
<pre><code class="language-sh">curl -fsSL https://raw.githubusercontent.com/wasm-forge/ic-rusqlite/main/prepare.sh | sh
</code></pre>
<p>The script will:</p>
<ul>
<li>install <code>wasi2ic</code>: <code>cargo install wasi2ic</code></li>
<li>install WASI target: <code>rustup target add wasm32-wasip1</code></li>
<li>download <code>WASI-SDK</code> and WASI-oriented <code>clang</code>: <a href="https://github.com/WebAssembly/wasi-sdk/releases/">WASI-SDK</a>.</li>
<li>Finally, define variables in your <code>.bashrc</code>:</li>
</ul>
<pre><code class="language-sh">export WASI_SDK=&lt;path to wasi-sdk&gt;
export PATH=$WASI_SDK/bin:$PATH
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-your-sqlite-canister"><a class="header" href="#creating-your-sqlite-canister">Creating Your SQLite Canister</a></h1>
<h2 id="configure-your-canister"><a class="header" href="#configure-your-canister">Configure your canister</a></h2>
<p>To integrate SQLite into your backend Rust Canister project, you will need to add the <code>ic-rusqlite</code> dependency and adjust the build process.</p>
<p>The first part is easy:</p>
<pre><code class="language-bash">cargo add ic-rusqlite
</code></pre>
<p>The second part requires you to update the <code>dfx.json</code> to specify path to <code>wasm</code> binary, set cansiter <code>type</code> to <code>custom</code>, and
specify custom build steps to enforce compilation to the <code>wasm32-wasip1</code> target.
Finally, use <code>wasi2ic</code> to produce a Wasm executable on the Internet Computer.</p>
<p>Example <code>dfx.json</code>:</p>
<pre><code class="language-json">{
  "canisters": {
    "backend": {
      "candid": "can.did",
      "package": "backend",
      "build": [
        "cargo build --release --target wasm32-wasip1",
        "wasi2ic target/wasm32-wasip1/release/backend.wasm target/wasm32-wasip1/release/backend_nowasi.wasm"
      ],
      "wasm": "target/wasm32-wasip1/release/backend_nowasi.wasm",
      "type": "custom",
      "metadata": [
        {
          "name": "candid:service"
        }
      ]
    }
  },
  "dfx": "0.28.0",
  "version": 1
}
</code></pre>
<h2 id="accessing-the-database"><a class="header" href="#accessing-the-database">Accessing the Database</a></h2>
<p>The database connection is established with the first call to <code>ic_rusqlite::with_connection(...)</code>, so there is no need to explicitly initialize or create a database.</p>
<p>Internally, the <code>ic-rusqlite</code> uses <a href="https://dfinity.github.io/stable-structures/">stable structures</a> with the <a href="https://dfinity.github.io/stable-structures/concepts/memory-manager.html">memory manager</a>. The virtual memories <code>101..119</code> are reserved for the file system.</p>
<p>The virtual memory with the ID <code>120</code> is the default storage memory for the database database file is <code>/DB/main.db</code>. These settings are default, but can be change via the <code>set_connection_config(...)</code> function.</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="creating_canister.html#admonition-note"></a>
</div>
<div>
<p>The ability to associate a file with a virtual memory is a special feature of <a href="https://github.com/wasm-forge/stable-fs"><code>stable-fs</code></a>. This allows to create dedicated files with fast I/O access.</p>
</div>
</div>
<h2 id="using-file-system"><a class="header" href="#using-file-system">Using File System</a></h2>
<p><code>ic-rusqlite</code> is compiled to the WASI target and then processed by the <a href="https://github.com/wasm-forge/wasi2ic"><code>wasi2ic</code> workflow</a>, embedding <code>ic-wasi-polyfill</code> and <code>stable-fs</code> into the output binary. This enables the use of standard Rust I/O APIs for file operations.</p>
<div id="admonition-note-1" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-1-title">
<div class="admonition-title">
<div id="admonition-note-1-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="creating_canister.html#admonition-note-1"></a>
</div>
<div>
<p>By default the main database file is stored in the root folder: <code>/DB/main.db</code> and there are a few additional <a href="https://www.sqlite.org/tempfiles.html">helper files</a> that can be created by the databsae engine.</p>
</div>
</div>
<h2 id="using-stable-structures"><a class="header" href="#using-stable-structures">Using Stable Structures</a></h2>
<p>You can freely create other stable structures for your extra storage needs, just make sure to use a virtual memory ID that is not yet occupied.</p>
<div id="admonition-use-memory-manager" class="admonition admonish-warning" role="note" aria-labelledby="admonition-use-memory-manager-title">
<div class="admonition-title">
<div id="admonition-use-memory-manager-title">
<p>Use Memory Manager</p>
</div>
<a class="admonition-anchor-link" href="creating_canister.html#admonition-use-memory-manager"></a>
</div>
<div>
<p>Make sure <a href="https://docs.rs/ic-stable-structures/latest/ic_stable_structures/#example-canister"><strong>you are using the memory manager</strong></a> or you will destroy the database and the file system stored in the stable memory.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-canister-example"><a class="header" href="#basic-canister-example">Basic Canister Example</a></h1>
<p>A very basic canister backend for storing persons can look as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use ic_rusqlite::with_connection;

#[ic_cdk::update]
fn add(name: String, data: String, age: u32) {
    with_connection(|conn| {
        // execute statement with parameters
        conn.execute(
            "INSERT INTO person (name, data, age) VALUES (?1, ?2, ?3)",
            (&amp;name, &amp;data, age),
        )
        .unwrap();
    })
}

#[ic_cdk::query]
fn list() -&gt; Vec&lt;(u64, String, String, u32)&gt; {
    with_connection(|conn| {
        // prepare SQL statement
        let mut stmt = conn
            .prepare("SELECT id, name, data, age FROM person")
            .unwrap();

        // execute statement and map results into an iterator
        let iter = stmt
            .query_map([], |row| {
                Ok((row.get(0)?, row.get(1)?, row.get(2)?, row.get(3)?))
            })
            .unwrap();

        iter.map(|r| r.unwrap()).collect()

    })
}

#[ic_cdk::init]
fn init() {
    with_connection(|conn| {
        // create the initial tables on the first deployment

        conn.execute(
            "CREATE TABLE IF NOT EXISTS person (
                id    INTEGER PRIMARY KEY,
                name  TEXT NOT NULL,
                data  TEXT,
                age   INTEGER
            )",
            (),
        )
        .unwrap();

    })

}
<span class="boring">}</span></code></pre></pre>
<p>For a complete picture of what you can accomplish with a <code>Connection</code>, see the <a href="https://docs.rs/rusqlite/latest/rusqlite/struct.Connection.html"><strong>rusqlite</strong> documentation</a>.</p>
<h2 id="creating-a-custom-database-connection"><a class="header" href="#creating-a-custom-database-connection">Creating a custom database connection</a></h2>
<p>You can create a customized database connection, in case you want to store it in another file mount onto another virtual memory or customize its initial pragma settings:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[init]
fn init() {
    // default configuration
    let mut config = ic_rusqlite::ConnectionConfig::new();

    // optinally, create a custom connection to a database different from the default one
    config.db_file_name = "/my_custom_path/my_base.db".to_string(); // some custom path to the database
    config.db_file_mount_id = Some(150); // store database in the virtual memory ID 150
    config
        .pragma_settings
        .insert("cache_size".to_string(), "10000".to_string()); // modify the default pragma settings

    ic_rusqlite::set_connection_config(config);
    //...
    // The actual connection is not needed here, it will be done automatically on the next "with_connection" statement.
}

#[pre_upgrade]
fn pre_upgrade() {
    // closing connection explicitly unlocks the database before canister upgrade
    ic_rusqlite::close_connection();
}

#[post_upgrade]
fn post_upgrade() {
    // same initialization
    init();
}
<span class="boring">}</span></code></pre></pre>
<p>In this example, we explicitly close the database connection in the <code>pre_upgrade</code> hook. This ensures that the database lock is released, preventing any issues when creating a new connection after the canister upgrade.</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="basic_example.html#admonition-note"></a>
</div>
<div>
<p><strong>Note:</strong> Since the canister operates in single-user mode, there is no risk of conflicts from concurrent connections. Therefore, <code>ic-rusqlite</code> will attempt to delete the lock file when establishing a database connection, if one is found. This means that even if you do not explicitly close the connection, you will not be locked out of the database after an upgrade. However, the situation is different if the database remains locked and, after a canister upgrade, you attempt to use it with an <a href="https://www.sqlite.org/lang_attach.html"><code>ATTACH DATABASE</code></a> query.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ic-rusqlite-users-orders-benchmark"><a class="header" href="#ic-rusqlite-users-orders-benchmark"><code>ic-rusqlite</code> Users-Orders Benchmark</a></h1>
<p>This project benchmarks <code>ic-rusqlite</code> dependency on a benchmark canister, the original benchmark project can be found here in the <a href="https://github.com/wasm-forge/benchmarks/tree/main/sql-users-orders">benchmarks repository</a>.</p>
<h2 id="pragma-settings"><a class="header" href="#pragma-settings">Pragma settings</a></h2>
<p>This shows the current benchmark results for database performance based on a database file that writes directly to a stable memory (minimized chunked storage overheads).</p>
<p>Following <a href="https://sqlite.org/pragma.html">pragma</a> settings:</p>
<div class="table-wrapper"><table><thead><tr><th>Pragma</th><th>Value</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="https://sqlite.org/pragma.html#pragma_journal_mode">journal</a></td><td>PERSIST</td><td>persist journal file (is faster than deleting the file every time). Setting it to <code>OFF</code> works faster, but <a href="https://sqlite.org/pragma.html#pragma_journal_mode">disallows atomic COMMIT/ROLLBACK</a></td></tr>
<tr><td><a href="https://sqlite.org/pragma.html#synchronous">synchronous</a></td><td>NORMAL</td><td>a readonable value for data safety and performance</td></tr>
<tr><td><a href="https://sqlite.org/pragma.html#page_size">page_size</a></td><td>4096</td><td>a reasonable default value</td></tr>
<tr><td><a href="https://sqlite.org/pragma.html#locking_mode">locking_mode</a></td><td>EXCLUSIVE</td><td>exclusive mode is faster because we avoid locking and unlocking the database for each query</td></tr>
<tr><td><a href="https://sqlite.org/pragma.html#temp_store">temp_store</a></td><td>MEMORY</td><td>causes to keep the temporary data in memory, at the moment this is necessary to avoid sqlite cash during complex queries</td></tr>
<tr><td><a href="https://sqlite.org/pragma.html#cache_size">cache_size</a></td><td>1000000</td><td>gives a significant performance boost at the expence of the canister memory used. (It tries to keep the whole database in memory, thus reducing read operation request count)</td></tr>
</tbody></table>
</div>
<h2 id="database-structure"><a class="header" href="#database-structure">Database structure</a></h2>
<pre><code class="language-sql">CREATE TABLE users (
  user_id INTEGER PRIMARY KEY AUTOINCREMENT,
  username TEXT NOT NULL,
  email TEXT NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE orders (
  order_id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id INTEGER NOT NULL,
  amount REAL NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (user_id) REFERENCES users(user_id)
);
</code></pre>
<h2 id="benchmark-results"><a class="header" href="#benchmark-results">Benchmark results</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Test</th><th>Cycles cost</th></tr></thead><tbody>
<tr><td>Create 100 000 users (cached <code>INSERT</code> query with parameters executed 100000 times).</td><td>1.94 B</td></tr>
<tr><td>Create 1M orders (each refers to one of the users, no extra indexes present)</td><td>20.05 B</td></tr>
<tr><td>Create indexes, when there are 1M orders in the table: <code>CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);CREATE INDEX IF NOT EXISTS idx_orders_user_id ON orders(user_id);</code></td><td>6.27 B</td></tr>
<tr><td>Make a joint selection (100K users, 1M orders): <code>SELECT u.user_id, u.username, o.order_id, o.amount FROM users u JOIN orders o ON u.user_id = o.user_id WHERE u.user_id &lt; 1000 ORDER BY o.created_at DESC;</code></td><td>202.28 M</td></tr>
<tr><td>Select using <code>LIKE</code> on an indexed field: <code>SELECT * FROM users WHERE email LIKE 'user%'</code></td><td>781.46 M</td></tr>
<tr><td>Create 100 extra orders after there were already 1M orders and field indexes created.</td><td>9.03 M</td></tr>
<tr><td>Remove 1000 orders (we remove all orders from the first 100 users): <code>DELETE FROM orders WHERE user_id &lt;= 100</code></td><td>23.14 M</td></tr>
<tr><td>Create 1M orders after indices were created</td><td>29.88 B</td></tr>
<tr><td>Delete 100000 orders with transaction rollback: <code>BEGIN TRANSACTION; DELETE FROM orders WHERE order_id &gt; 900000; ROLLBACK</code></td><td>1.53 B</td></tr>
</tbody></table>
</div>
<h2 id="reproducing-the-benchmarks"><a class="header" href="#reproducing-the-benchmarks">Reproducing the Benchmarks</a></h2>
<p>Check out the Benchmark repository <a href="https://github.com/wasm-forge/benchmarks/tree/main/sql-users-orders">sql-users-orders</a> if you wish to repeat or examine the experiment.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-sqlite-on-a-large-dataset"><a class="header" href="#testing-sqlite-on-a-large-dataset">Testing SQLite on a Large Dataset</a></h1>
<p>To build a large database, the sample <a href="https://www.sqlitetutorial.net/wp-content/uploads/2018/03/chinook.zip"><code>Chinook</code> database</a> from the <a href="https://www.sqlitetutorial.net">SQLite tutorial</a> was used.</p>
<p><img src="img/chinook-erd.png" alt="Chinook Entity Relationship Diagram" /></p>
<p>The <code>customers</code> table was constantly filled with relatively large rows, until the table has reached <code>1115397</code> rows and the DB size has grown to <code>80_106_637_312</code> bytes.</p>
<p>The <code>first name</code> and <code>last name</code> are generated as a string concatenation: <code>{id}customer_name{id}</code> and <code>{id}customer_last_name{id}</code>, so that all names are unique.</p>
<h2 id="benchmarks"><a class="header" href="#benchmarks">Benchmarks</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Test</th><th>Cycles cost (first run)</th><th>Cycles cost (second run)</th></tr></thead><tbody>
<tr><td>Count elements on the first call: <code>SELECT COUNT(*) FROM customers</code></td><td>12392402159</td><td>6205886</td></tr>
<tr><td>Customer search by row ID: <code>SELECT firstname, lastname, email WHERE customer_id=900000</code></td><td>36316014</td><td>84516</td></tr>
<tr><td>Select by the indexed field first name by the exact match: <code>SELECT firstname, lastname, email FROM customers WHERE firstname = "2912169customer_name2912169"</code></td><td>33252345</td><td>62988</td></tr>
<tr><td>Select by first name, that does not exist: <code>SELECT firstname, lastname, email FROM customers WHERE firstname = "1"</code></td><td>30067131</td><td>60316</td></tr>
<tr><td>Customer search by row ID: <code>SELECT firstname, lastname, email FROM customers WHERE customerid&gt;900000 and customerid&lt;900050</code></td><td>63839343</td><td>1821716</td></tr>
<tr><td>Customer count depending on the <code>first name</code>: <code>SELECT count(*) FROM customers WHERE firstname&gt;="1" and firstname&lt;"2"</code></td><td>6498875034</td><td>254846762</td></tr>
<tr><td>Select a person that doesn't exist using <code>LIKE</code>: <code>SELECT firstname, lastname, email FROM customers WHERE firstname LIKE "a%"</code></td><td>Failed</td><td></td></tr>
<tr><td>Select a person using <code>OFFSET</code>: <code>SELECT firstname, lastname, email FROM customers WHERE firstname LIKE "a%"</code></td><td>Failed</td><td></td></tr>
</tbody></table>
</div><div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="large_database.html#admonition-note"></a>
</div>
<div>
<p><strong>Note:</strong> Both failing queries require full table scan, and SQLite is not able to process that amount within estimated time, you can check if a query is going for a full scan by prepending <code>EXPLAIN QUERY PLAN</code> to your query:</p>
<p><code>EXPLAIN QUERY PLAN SELECT firstname, lastname, email FROM customers LIMIT 5 OFFSET 900000</code></p>
</div>
</div>
<p>This test shows that it is possible to create a very large database, it is however, not as optimal as one might expect. On a large database some operations will always fail because they would require too many cycles. The exact limit on the database size may depend on many aspects such as the page size, the row size and number, and the table structure. The actual "practial" database size might be in range from 2GiB to 20GiB, which might be enough in the majority of usecases.</p>
<h2 id="reproducing-the-benchmarks-1"><a class="header" href="#reproducing-the-benchmarks-1">Reproducing the Benchmarks</a></h2>
<p>Check out the Benchmark repository <a href="https://github.com/wasm-forge/benchmarks/tree/main/ic-chinook-base">ic-chinook-base</a> if you wish to repeat or examine the experiment.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tips-on-working-with-large-datasets"><a class="header" href="#tips-on-working-with-large-datasets">Tips on Working with Large Datasets</a></h1>
<ul>
<li><strong>Use indexed queries.</strong></li>
</ul>
<p>Plan ahead, which fields will be critical to search the right elements and create indexes on those fields. For example, if you need to quickly find a person by <code>name</code>, make sure this <code>name</code> field is indexed:</p>
<pre><code class="language-sql">CREATE INDEX IF NOT EXISTS idx_persons_name ON customers(name);
</code></pre>
<p>Also plan how you store your data. If you store the <code>first_name</code> and <code>last_name</code> concatenated in the same column, it won’t be possible to efficiently search by last_name without performing a full table scan, e.g.:</p>
<pre><code class="language-sql">... WHERE name LIKE '%Johnson'
</code></pre>
<ul>
<li><strong>Check Instructions passed to see if you want to quit early and bulk insertions.</strong></li>
</ul>
<ol>
<li>
<p>When processing queries iteratively, check timing constraints inside the loop. If there isn’t enough time to complete the operation, exit early with a partial result rather than letting the process overrun.</p>
</li>
<li>
<p>Every call to <code>execute</code> opens and closes a transaction. To improve performance when inserting many records, open a transaction before the first insert and commit changes only once after all inserts are complete. This avoids committing after each row:</p>
</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[ic_cdk::update]
fn add_customers(id_offset: u64) {
    let start = ic_instruction_counter();

    with_connection(|mut conn| {
        let tx = conn.transaction().unwrap();

        let sql =
            String::from("insert into customers (firstname, lastname, email) values (?, ?, ?)");

        {
            let mut stmt = tx.prepare_cached(&amp;sql).unwrap();

            let mut i = 0;

            // do as many rows as the timing allows
            while i &lt; 100000000 {
                let id = id_offset + i + 1;
                let name = format!("{id}customer_name{id}");
                let last_name = format!("{id}customer_last_name{id}");
                let email = format!("{id}customer@example.com");

                stmt.execute(ic_rusqlite::params![name, last_name, email])
                    .expect("insert of a user failed!");

                i += 1;

                //
                let end = ic_instruction_counter();
                if end - start &gt; 20000000000 {
                    break;
                }
            }
        }

        tx.commit().expect("COMMIT USER INSERTION FAILED!");
    });
}

<span class="boring">}</span></code></pre></pre>
<ul>
<li><strong>Examine query plan.</strong></li>
</ul>
<p>To identify problems with a complex or slow query, study its <a href="https://www.sqlite.org/eqp.html">query plan</a>.
See if there are any full scans on a table, you might want to change the query logic and/or introduce indexes.</p>
<ul>
<li><strong>Use pagination.</strong></li>
</ul>
<p>To avoid running out of instructions and the returned data size on potentially large datasets, it is possible to limit the number of data rows returned by the SQL query. Use <code>LIMIT &lt;N&gt;</code> to limit the number of rows returned by a query, and <code>OFFSET &lt;N&gt;</code> to skip the first <code>N</code> rows of a response.</p>
<p>To return at most 5 persons and skip the first 3, write:</p>
<pre><code class="language-sql">SELECT * FROM persons LIMIT 5 OFFSET 3
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pragma-settings-1"><a class="header" href="#pragma-settings-1">Pragma settings</a></h1>
<p>Following <a href="https://sqlite.org/pragma.html">pragma</a> settings are set in <code>ic-rusqlite</code> by default:</p>
<p><em><a href="https://sqlite.org/pragma.html#pragma_journal_mode">journal_mode</a></em>
- <code>PERSIST</code>
- persist journal file (is faster than deleting the file every time). Setting it to <code>OFF</code> works even faster, but <a href="https://sqlite.org/pragma.html#pragma_journal_mode">disallows atomic COMMIT/ROLLBACK</a>.</p>
<p><em><a href="https://sqlite.org/pragma.html#synchronous">synchronous</a></em>
- <code>OFF</code>
- because writes are always written and not cached, we do not need to explicity "flush" data changes to the disk.</p>
<p><em><a href="https://sqlite.org/pragma.html#page_size">page_size</a></em>
- <code>4096</code>
- bigger page size works a bit faster by reduring sequential writes. The performance degrades, however, if there are many small writes at random locations.</p>
<p><em><a href="https://sqlite.org/pragma.html#locking_mode">locking_mode</a></em><br />
- <code>EXCLUSIVE</code><br />
- exclusive mode is faster because we only lock the database once (the canister is the only user of the database).</p>
<p><em><a href="https://sqlite.org/pragma.html#temp_store">temp_store</a></em>
- <code>MEMORY</code><br />
- avoids creating temporary file on disk, saves extra I/O operations.</p>
<p><em><a href="https://sqlite.org/pragma.html#cache_size">cache_size</a></em>
- <code>500000</code>
- set cache size to 4096 * 500000 bytes, this gives a significant performance boost at the expence of the canister's memory used.</p>
<p>The pragma settings can be adjusted with SQL queries, you might want to do that during the <code>init</code> or the <code>post_upgrade</code> events:</p>
<pre><code class="language-sql">    PRAGMA cache_size=1000; -- Reduce the maximum DB cache size
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="when-is-sqlite-appropriate"><a class="header" href="#when-is-sqlite-appropriate">When Is SQLite Appropriate?</a></h1>
<p>SQLite is a fast, lightweight SQL database that stores all data in a single file. This works well with a canister's memory model, but there are pros and cons to consider before choosing it.</p>
<h2 id="when-to-use-sqlite"><a class="header" href="#when-to-use-sqlite">When to Use SQLite</a></h2>
<p>SQLite is ideal when you need structured, reliable, and transactional data storage but don’t want the complexity of running a database server.</p>
<ul>
<li>
<p><strong>You need complex queries.</strong>
SQLite supports standard SQL, allowing you to perform advanced queries using <code>SELECT</code>, <code>JOIN</code>, <code>GROUP BY</code>, and other operations.</p>
</li>
<li>
<p><strong>You need transactions.</strong>
SQLite is ACID-compliant, so it guarantees data consistency, supports rollback, and handles multi-step operations safely.</p>
</li>
<li>
<p><strong>Tabular data with multiple indexes.</strong>
SQLite is useful, if you have a large table and you want to find records by multiple indexed fields.</p>
</li>
</ul>
<h2 id="when-to-use-stable-structures"><a class="header" href="#when-to-use-stable-structures">When to Use Stable Structures</a></h2>
<p>If your data needs are simple, stable structures may be faster and easier to use.</p>
<p><strong>Use a stable structure like <code>Vec</code>, <code>BTreeMap</code>, or <code>BTreeSet</code> when:</strong></p>
<ul>
<li>
<p><strong>You don’t need transactions.</strong>
If you don’t need rollback or atomic updates.</p>
</li>
<li>
<p><strong>You don’t need SQL-style queries.</strong>
For simple <code>key -&gt; value</code> dictionary search, stable data structures are faster and easier to work with.</p>
</li>
<li>
<p><strong>You need speed over flexibility.</strong>
Structures like <code>Vec</code> provide O(1) index-based access, and <code>BTreeMap</code> gives sorted access with logarithmic complexity — both are faster than SQLite for many common tasks.</p>
</li>
</ul>
<h2 id="when-to-use-the-file-system"><a class="header" href="#when-to-use-the-file-system">When to Use the File System</a></h2>
<p>For file-based hierarchical data, the file system may be the best choice.</p>
<p><strong>Use the file system storage when:</strong></p>
<ul>
<li>
<p><strong>You want to organize data into directories and subfolders.</strong>
Storing backups and documents.</p>
</li>
<li>
<p><strong>You work with large data.</strong>
Files are larger than the canister's heap memory and/or contain large sections of zeroed memory (<a href="https://en.wikipedia.org/wiki/Sparse_file">sparse files</a>).</p>
</li>
<li>
<p><strong>You perform byte-level data manipulation.</strong>
Editing or seeking within large files is faster with standard file I/O than loading and modifying data through an SQL database.</p>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
