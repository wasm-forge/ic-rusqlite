type Error = variant {
    InvalidCanister;
    CanisterError : record {
        message : text;
    };
};

type Result = variant {
    Ok: text;
    Err : Error;
};

type QueryResult = variant {
  Ok: vec vec text;
  Err: Error;
};


type Person = record {
    name: text;
    age: nat64
};

type QueryParams = record {
    limit: nat64;
    offset: nat64;
};

type FilterParams = record {
    name: text
};

type UpdateParams = record {
    id: nat64;
    name: text;
};

service : {
    "create": () -> (Result);
    "query": (text) -> (QueryResult);
    "execute": (text) -> (Result);
    "query_filter": (FilterParams) -> (Result) query;
    "insert": (Person) -> (Result);
    "delete": (nat64) -> (Result);
    "update": (UpdateParams) -> (Result);
    "ls_path": (text) -> (vec text);

    db_upload: (offset: nat64, content: blob) -> ();
    db_download: (offset: nat64) -> (blob) query;
}


//////////////////////////

service : {
    "add": (name: text, data: text, age: nat32) -> ();
    "list": () -> (vec record {nat64; text; text; nat32});
}



use ic_rusqlite::with_connection;

#[ic_cdk::init]
fn init() {
    with_connection(|conn| {
        // create the initial tables on the first deployment

        conn.execute(
            "CREATE TABLE IF NOT EXISTS person (
                id    INTEGER PRIMARY KEY,
                name  TEXT NOT NULL,
                data  TEXT,
                age   INTEGER
            )",
            (),
        )
        .unwrap();

    })

}

#[ic_cdk::update]
fn add(name: String, data: String, age: u32) {
    with_connection(|conn| {
        // execute statement with parameters
        conn.execute(
            "INSERT INTO person (name, data, age) VALUES (?1, ?2, ?3)",
            (&name, &data, age),
        )
        .unwrap();
    })
}

#[ic_cdk::query]
fn list() -> Vec<(u64, String, String, u32)> {
    with_connection(|conn| {
        // prepare SQL statement
        let mut stmt = conn
            .prepare("SELECT id, name, data, age FROM person")
            .unwrap();

        // execute statement and map results into an iterator
        let iter = stmt
            .query_map([], |row| {
                Ok((row.get(0)?, row.get(1)?, row.get(2)?, row.get(3)?))
            })
            .unwrap();

        iter.map(|r| r.unwrap()).collect()

    })
}
